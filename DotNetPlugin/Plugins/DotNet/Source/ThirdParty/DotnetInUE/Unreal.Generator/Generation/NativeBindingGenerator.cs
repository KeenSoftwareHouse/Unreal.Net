// Copyright (c) 2021 Keen Software House
// Licensed under the MIT license.

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Unreal.ErrorHandling;
using Unreal.Marshalling;
using Unreal.Metadata;
using Unreal.NativeMetadata;
using Unreal.Util;
using TypeKind = Unreal.Metadata.TypeKind;

namespace Unreal.Generation
{
    // Generates targets for native bindings.
    public class NativeBindingGenerator : GeneratorBase
    {
        private MissingSymbolHandling m_missingSymbolHandling;

        private readonly List<(TypeWriter TypeWriter, UEStruct Data)> m_generatedTypes = new();

        private Dictionary<(string Namespace, string Name), TypeDeclarationSyntax> m_syntaxes = null!;

        private readonly List<UEClass> m_classes = new();

        private readonly List<UEStruct> m_structs = new();

        private readonly List<EnumWriter> m_enums = new();

        private NativeGenerationStats m_stats;

        public NativeBindingGenerator(GenerationCoordinator coordinator)
            : base(coordinator)
        { }

        public override void CollectTypes(TypeDeclarationSyntax[] declaredTypes)
        {
            // For new we default to skip, this is because in rider we don't get any msbuild variables,
            // which makes it default to error and fail the entire build, leaving us with no code analysis help.
            // Plus, it's fine to do that because the default msbuild property is already set to Error. So the only case]
            // that really matters to us is when the variable does not come to us. 
            m_missingSymbolHandling =
                ExecutionContext.GetMsBuildProperty("UnrealNativeBindingsMissingSymbolHandling", MissingSymbolHandling.Skip);

            m_syntaxes = declaredTypes.ToDictionary(x => (Namespace: x.GetNamespace(), Name: x.Identifier.ValueText));

            // Collect types.
            // ==============
            foreach (var text in ExecutionContext.AdditionalFiles)
            {
                if (!text.Path.EndsWith(".umeta"))
                    continue;

                var sourceText = text.GetText();
                if (sourceText == null)
                    continue;

                UEMeta meta;
                try
                {
                    var data = sourceText.ToString();
                    meta = MetadataCollector.LoadFromString(data);
                }
                catch (Exception e)
                {
                    throw new NativeMetadataException(Path.GetFileNameWithoutExtension(text.Path), e.Message);
                }

                if (meta is UEField field)
                {
                    if (field.Meta.ContainsKey(MetaAttribute.ManagedTypeAttributeName))
                        continue; // Skip types that were generated by us already

                    if (field.Meta.TryGetValue("ModuleRelativePath", out var relativePath)
                        && relativePath.StartsWith("Private"))
                        continue;

                    if (field is UEStruct @struct)
                    {
                        if (field is UEClass @class)
                        {
                            if (TypeBlacklist.Contains(@class.CppName))
                                continue;

                            m_classes.Add(@class);
                        }
                        else
                        {
                            m_stats.TotalStructs++;

                            // TODO: Support properties with object references.
                            if (@struct.Properties.Any(x => x.PropertyType == "ObjectProperty"))
                            {
                                m_stats.SkippedStructReferenceType++;
                                continue;
                            }

                            m_structs.Add(@struct);
                        }
                    }
                    else if (field is UEEnum @enum)
                    {
                        CollectEnum(@enum);
                    }
                }
                else if (meta is UEModule module)
                {
                    ModuleWriter.NativeModules.Add(module.Name);
                }
            }

            // TODO: Interfaces
            m_stats.TotalEnums = m_enums.Count;
            m_stats.TotalClasses = m_classes.Count;

            if (m_structs.Count == 0 && m_classes.Count == 0 && m_enums.Count == 0)
                return;

            // Write module bits.
            // ==================

            SortStructs(m_structs);
            SortStructs(m_classes);

            // Processing classes in order should allow us to catch parents correctly.q
            foreach (var type in m_classes)
            {
                try
                {
                    // Collect type.
                    var classBuilder = TypeDefinition.PrepareFromNative(Module, Context, type)
                        .AppendComment($"Flags = {type.Flags}");

                    // Link to symbol if another part is defined.
                    if (m_syntaxes.TryGetValue((classBuilder.Namespace, classBuilder.Name), out var managedPart))
                    {
                        var model = Context.Compilation.GetSemanticModel(managedPart.SyntaxTree);
                        var symbol = (INamedTypeSymbol) model.GetDeclaredSymbol(managedPart)!;
                        classBuilder.WithTypeSymbol(symbol);
                    }

                    // Types with no api attribute *or* no header should be considered NoAPI.
                    // We make an exception for CoreUObject because those types don't really have any functions anyway. 
                    if ((type.Flags & ClassFlags.RequiredAPI) == 0
                        || (type.Module != "CoreUObject" && classBuilder.Header == ""))
                        classBuilder.WithManagedAttribute("NoAPI");

                    var cls = classBuilder.Build();
                    var writer = ClassWriter.CreateUObjectWriter(cls, Codespace.Managed);

                    AddType(writer);

                    m_generatedTypes.Add((writer, type));
                }
                catch (GenerationException ex)
                {
                    Error(ex);
                }
            }

            foreach (var structInfo in m_structs)
            {
                try
                {
                    // Collect type.
                    var structDefinition = TypeDefinition.PrepareFromNative(Module, Context, structInfo)
                        .WithManagedAttribute($"StructLayout(LayoutKind.Explicit, Size={structInfo.Size})")
                        .WithDefaultMarshaller(PassByReferenceMarshaller.Instance)
                        .Build();

                    var writer = new StructWriter(structDefinition)
                    {
                        HasGeneratedHeader = true,
                        AdditionalNamespaces = { "System.Runtime.InteropServices" },
                        Components = MemberCodeComponentFlags.ManagedPart
                    };

                    AddType(writer);
                    m_generatedTypes.Add((writer, structInfo));
                    //moduleWriter.TypesForRegistration.Add(writer.Member);
                }
                catch (GenerationException ex)
                {
                    Error(ex);
                }
            }
        }

        public override void ProcessAndExportTypes()
        {
            // Second pass to collect members.
            foreach (var (typeWriter, typeData) in m_generatedTypes)
            {
                try
                {
                    var hasApi = !typeWriter.Member.ManagedAttributes.Contains("NoAPI");

                    m_syntaxes.TryGetValue((typeWriter.Member.Namespace, typeWriter.Member.ManagedName),
                        out var part);

                    FinishBasicType(typeWriter, ModuleWriter, part, hasApi);

                    // Skip generation of methods for NoAPI types.
                    CollectMembers(typeWriter, typeData, hasApi);
                }
                catch (GenerationException ex)
                {
                    Error(ex);
                }
            }

            foreach (var typeWriter in m_generatedTypes.Select(x => x.TypeWriter).Concat(m_enums))
            {
                // TODO: Check assembly default namespace instead.
                // Also we'd like to unify this with the base class since it already collects the writers.
                // Doing it at the type writer level would be best.
                var unreal = "Unreal.";

                var ns = typeWriter.Member.Namespace;
                ns = ns.StartsWith(unreal) ? ns.Substring(unreal.Length) : ns;

                WriteComponents(typeWriter, ns);
            }
        }

        private void FinishBasicType(TypeWriter typeWriter, ModuleWriter moduleWriter,
            TypeDeclarationSyntax? typeDeclarationSyntax, bool hasAPI)
        {
            if (typeWriter.Member.Kind == TypeKind.Class)
            {
                ClassWriter.AddStaticClassMembers(Context, moduleWriter, (ClassWriter) typeWriter, hasAPI);

                // Find part.
                if (typeDeclarationSyntax != null)
                {
                    var model = Context.Compilation.GetSemanticModel(typeDeclarationSyntax.SyntaxTree);

                    MethodDeclarationSyntax? ctor = null;

                    // Search for special functions.
                    foreach (var functionSyntax in typeDeclarationSyntax.Members.OfType<MethodDeclarationSyntax>())
                    {
                        if (!functionSyntax.AttributeLists.ContainsAttributeType(model, Context.ConstructorAttribute))
                            continue;

                        if (ctor != null)
                            Error(new SourceException("Class may only declare one constructor.", functionSyntax));

                        ctor = functionSyntax;

                        ValidateSpecialSignature(model, ctor);
                    }

                    if (ctor != null)
                    {
                        // Relying on the 
                        var ctorWriter = typeWriter.Members.OfType<FunctionWriter>()
                            .FirstOrDefault(f =>
                                f.Member.SpecialMethod == MethodSpecialType.Constructor
                                && f.Name == ClassWriter.RealConstructorName);

                        Debug.Assert(ctorWriter != null, "All class types should have defined ctors.");

                        var functionName = ctor.Identifier.ValueText;
                        if (ctorWriter!.CustomBody != "")
                            ctorWriter.CustomBody = $"{ctorWriter.CustomBody}\n{functionName}();";
                        else
                            ctorWriter.CustomBody = $"{functionName}();";
                    }
                }
            }
        }

        private void CollectMembers(TypeWriter writer, UEStruct typeData, bool hasApi)
        {
            ErrorCollector collector = default;

            // TODO: Class Properties

            if (typeData is UEClass classData)
            {
                // Only collect functions of types with API access.
                // TODO: This might be fixable by calling reflection data directly. 
                if (hasApi)
                {
                    bool anySkippedFunctions = false;

                    foreach (var ueFunction in classData.Functions)
                    {
                        m_stats.TotalFunctions++;

                        // TODO: Events and virtual methods:
                        // For now let's just skip what's not public
                        FunctionFlags flagsToIgnore =
                            FunctionFlags.BlueprintEvent
                            | FunctionFlags.Protected
                            | FunctionFlags.Private
                            | FunctionFlags.Delegate;

                        if ((ueFunction.Flags & flagsToIgnore) != 0)
                            continue;

                        // Custom thunk functions are fake and don't actually have an implementation we can call.
                        if (ueFunction.Meta.ContainsKey("CustomThunk"))
                            continue;

                        try
                        {
                            var fn = FunctionDefinition.PrepareFromNative(Context, writer.Member, ueFunction).Build();
                            var functionWriter = new NativeFunctionBinder(fn);
                            writer.AddMember(functionWriter);
                        }
                        catch (GenerationException ex)
                        {
                            if (ex is MissingSymbolException ms)
                                ms.RequestingType = $"{writer.Member.NativeName}::{ueFunction.Name}";

                            m_stats.SkippedFunctions++;
                            anySkippedFunctions = true;
                            collector.Add(ex);
                        }
                    }

                    if (anySkippedFunctions)
                        m_stats.ClassesMissingFunctions++;
                }
                else
                {
                    m_stats.ClassesMissingFunctionsNoExport++;
                }
            }
            else
            {
                bool anySkippedProperties = false;
                // For now we're ignoring class properties.
                foreach (var ueProperty in typeData.Properties)
                {
                    m_stats.TotalProperties++;

                    try
                    {
                        var type = Context.TypeResolver.Resolve(ueProperty);

                        var prop = PropertyDefinition.PrepareFromNative(writer.Member, type, ueProperty)
                            .Build();

                        writer.AddMember(new PropertyWriter(prop, Codespace.Managed));
                    }
                    catch (GenerationException ex)
                    {
                        if (ex is MissingSymbolException ms)
                            ms.RequestingType = $"{writer.Member.NativeName}::{ueProperty.Name}";

                        m_stats.SkippedProperties++;
                        anySkippedProperties = true;
                        collector.Add(ex);
                    }
                }

                if (anySkippedProperties)
                    m_stats.StructsMissingProperties++;
            }

            collector.ThrowIfNeeded();
        }

        private static HashSet<string> TypeBlacklist = new()
        {
            // These are fine:
            "ULinkerPlaceholderClass",
            "ULinkerPlaceholderExportObject",
            "ULinkerPlaceholderFunction",
        };

        protected override void Error(GenerationException exception)
        {
            if (exception is MissingSymbolException mse)
                mse.ActualSeverity = ToDiagnosticSeverity(m_missingSymbolHandling);

            base.Error(exception);
        }

        private DiagnosticSeverity ToDiagnosticSeverity(MissingSymbolHandling handling)
        {
            return handling switch
            {
                MissingSymbolHandling.Error => DiagnosticSeverity.Error,
                MissingSymbolHandling.Warning => DiagnosticSeverity.Warning,
                MissingSymbolHandling.Skip => DiagnosticSeverity.Info, // Still visible in the log but not annoying
                _ => throw new ArgumentOutOfRangeException(nameof(handling), handling, null)
            };
        }

        private void SortStructs<T>(List<T> types)
            where T : UEStruct
        {
            Dictionary<string, (T Type, bool Inserted)> index = new();

            foreach (var type in types)
                index.Add(type.CppName, (type, false));

            // Reconstruct list.
            types.Clear();

            foreach (var current in index.Select(x => x.Value.Type).ToArray())
            {
                Add(current);

                // Recursive add parent first.
                void Add(T type)
                {
                    if (index[type.CppName].Inserted)
                        return;

                    // If parent type is in a different module or is unknown we leave that for later.
                    if (type.Parent != null && index.TryGetValue(type.Parent.CppName, out var entry))
                    {
                        // Check for cycles just in case.
                        if (entry.Type == current)
                        {
                            var hierarchy = type.CppName + GetHierarchy(type.CppName, type.CppName);
                            Error(new NativeMetadataException(type.CppName,
                                $"Cyclical inheritance hierarchy detected: {hierarchy}"));
                        }

                        if (!entry.Inserted)
                            Add(entry.Type);
                    }

                    // Mark as added.
                    index[type.CppName] = (type, true);
                    types.Add(type);
                }

                string GetHierarchy(string currentType, string startingType)
                {
                    return " -> "
                           + (startingType == currentType
                               ? currentType
                               : GetHierarchy(index[currentType].Type.Parent!.CppName, startingType));
                }
            }
        }

        private void CollectEnum(UEEnum enumInfo)
        {
            // TODO: Enum meta.
            var type = TypeDefinition.PrepareFromNative(Module, Context, enumInfo).Build();

            EnumPropertyWriter GetWriter(UEEnumValue x)
            {
                // TODO: Enums that are not namespaced usually have a prefix, we should be able to clean that up here as well for a nicer experience. 
                string name = x.Name;

                // Some enum values are recorded as Type::Value.
                if (x.Name.StartsWith(enumInfo.Name))
                    name = x.Name.Substring(enumInfo.Name.Length + 2);
                return new EnumPropertyWriter(PropertyDefinition.CreateBuilder(type, name)
                    .WithInitializer(x.Value.ToString())
                    .WithVisibility(SymbolVisibility.Public)
                    .Build(), Codespace.Managed);
            }

            var properties = enumInfo.Values.Select(GetWriter);

            // TODO: Detect flag enums.
            var writer = new EnumWriter(type, properties, Codespace.Managed, false);
            m_enums.Add(writer);
            AddType(writer);
        }
    }
}