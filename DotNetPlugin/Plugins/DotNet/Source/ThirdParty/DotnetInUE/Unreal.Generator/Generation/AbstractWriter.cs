// Copyright (c) 2021 Keen Software House
// Licensed under the MIT license.

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Unreal.Marshalling;
using Unreal.Metadata;

namespace Unreal.Generation
{
    public abstract class AbstractWriter
    {
        /// <summary>
        /// Codespaces that get meta flags written to them.
        /// </summary>
        public CodespaceFlags MetaSpace;

        /// <summary>
        /// Which code components this writer wants to write on.  
        /// </summary>
        public MemberCodeComponentFlags Components { get; set; }

        public abstract string Name { get; }

        public abstract Module Module { get; }

        /// <summary>
        /// Namespaces required by the managed parts of this member.
        /// </summary>
        public HashSet<string> AdditionalNamespaces { get; } = new();

        /// <summary>
        /// Headers required by the native parts of this member.
        /// </summary>
        public HashSet<string> AdditionalHeaders { get; } = new();

        public abstract void Write(CodeWriter writer, MemberCodeComponent component);

        public string GetFilename(MemberCodeComponent component)
        {
            if (component == MemberCodeComponent.Custom)
                return CustomFileName;

            var extension = component switch
            {
                MemberCodeComponent.ManagedPart => "cs",
                MemberCodeComponent.NativeFunctionDeclaration => "functions.h",
                MemberCodeComponent.NativeClassDeclaration => "h",
                MemberCodeComponent.NativeImplementation => "cpp",
                _ => throw new ArgumentOutOfRangeException(nameof(component), component, null)
            };

            return $"{Name}.{extension}";
        }

        /// <summary>
        /// Custom file name when this writer has a custom component.
        /// </summary>
        protected virtual string CustomFileName => "";

        /// <summary>
        /// Write the mani notices at the start of the file.
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="component"></param>
        protected void WriteFileHeader(CodeWriter writer, MemberCodeComponent component)
        {
            var file = GetFilename(component);
            var assemblyName = typeof(TypeWriter).Assembly.GetName();

            writer.WriteLine($@"//== GENERATED FILE ========================================{Module.Ticket:X16}====
//==============================================================================

// {file}
// Generated by {assemblyName.Name} v{assemblyName.Version}
// Changes to this file may be overwritten.
");
        }

        protected void WriteFileFooter(CodeWriter writer, MemberCodeComponent component)
        {
            var file = GetFilename(component);
            var time = Module.Timespamp;
            
            writer.WriteLine($@"
// End of {file}

//== GENERATED FILE ========================================{time}====
//==============================================================================");
        }

        protected void WriteIncludes(CodeWriter writer, List<MemberWriter> writers,
            TypeDefinition? typeToExclude = null)
        {
            // Collect all dependencies.
            HashSet<ITypeInfo> dependencies = new(GetTypeDependencies(Codespace.Native));

            // Remove the current type if we need it.
            if (typeToExclude != null)
                dependencies.Remove(typeToExclude);

            HashSet<string> headers = new();

            headers.UnionWith(AdditionalHeaders);
            headers.UnionWith(dependencies.Select(x => x.Header).Where(x => !string.IsNullOrWhiteSpace(x)));

            foreach (var header in headers)
                writer.WriteLine($"#include \"{header}\"");
        }

        protected void WriteNamespaces(CodeWriter writer, List<MemberWriter> writers,
            TypeDefinition? typeToExclude = null)
        {
            // Collect all dependencies.
            HashSet<ITypeInfo> dependencies = new(GetTypeDependencies(Codespace.Managed));

            // Remove the current type if we need it.
            if (typeToExclude != null)
                dependencies.Remove(typeToExclude);

            HashSet<string> namespaces = new();

            namespaces.UnionWith(AdditionalNamespaces);
            namespaces.UnionWith(dependencies.Select(x => x.Namespace).Where(x => !string.IsNullOrWhiteSpace(x)));

            bool written = false;

            foreach (var ns in namespaces.OrderBy(x => x))
            {
                writer.WriteLine($"using {ns};");
                written = true;
            }

            if (written)
                writer.WriteLine();
        }

        public virtual IEnumerable<ITypeInfo> GetTypeDependencies(Codespace space)
        {
            yield break;
        }
    }
}